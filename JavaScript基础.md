# JS语法基础
## 数据与数据类型
数据：有用的信息
数据类型：数据的分类

### JS中的数据类型
#### 原始类型
1. 数字类型 number
  > 了解：
  > 数字类型加上前缀 用来表示不同的进制
  > 0b: 表示2进制
  > 0: 表示8进制
  > 0x: 表示16进制
2. 字符串类型 string
  - 单引号 '
  - 双引号 "
  - 反引号 `
可以使用转义符"\"来表示特殊字符
3. 布尔类型 boolean
  - true
  - false
4. undefined类型
表示未定义 不存在。
5. null类型
表示空 不存在。

#### 引用类型
1. 对象 object
  **属性**: 对象的成员
2. 函数 function

**原始类型的变量 存放的是具体的值**
**引用类型的变量 存放的是内存地址**
**凡是出现对象字面量的位置 都一定在内存出现一个新的对象**

### 如何得到数据的类型
在数据前加上 typeof
<font color=#f00>typeof null 得到的是 object</font>

### 字面量
直接书写的具体数据

## 变量
变量是一块内存空间 用于保存数据

### 如何使用变量
1. 声明（定义）变量
```js
var 变量名
```
**变量声明后 值为undefined**
2. 给变量赋值
向变量的内存空间中存放数据
  - 变量的值是可变的
  变量可以被重新赋值 新的值会覆盖原来的值
  - 变量的名称
  凡是需要自行命名的位置 叫做标识符
  1）只能以英文字母、下划线、\$开头
  2）其他位置可以出现数字、英文字母、下划线、\$
  3）不可以与关键字、保留词重复
  4）标识符应做到望文知意
  5）如果有多个单词 使用驼峰命名法
    > 大驼峰：每个单词首字母大写
    > 小驼峰：除第一个单词外，首字母大写
    > 目前，使用的标识符都是小驼峰命名法。
  - 声明和赋值合并
    变量的声明和赋值可以用一条语句书写
  - 多个变量可以合并声明并赋值
  **任何可以书写数据的地方 都可以书写变量**
  - 若使用一个未声明的变量 会导致错误
  **JS中存在变量提升**
  - JS中允许定义多个同名变量
  同名变量提升后会变成一个。

## 变量和对象
### 在变量中存放对象
1. 通过变量 读取对象中的某个属性
   ```js
   变量名.属性名
   ```
   **当读取的属性不存在时 会得到undefined**
   **当读取属性的对象不存在（undefined或null）时程序报错**
2. 通过变量 改变对象中的某个属性
**当赋值的属性不存在时 会添加属性**
3. 删除属性
   ```js
   delete 变量名.属性名
   ```
4. 属性表达式
   ```js
   对象变量["属性名"]
   ```
   属性可以是任何形式的名字
   **属性的名字只能是字符串 如果写成数字 会自动转为字符串**
5. in关键字
判断某个属性在对象中是否存在
属性名 in 对象

### 全局对象
**定义的所有变量 实际上会成为window对象的属性**
**如果变量没有被赋值 则该变量不会覆盖window对象上的同名属性**


# 运算符
## 算数运算符
1. ```+ - * /```
2. ```+ -```
3. ```%```
4. ```++ --```
5. ```**```

### 细节
1. 数字运算是不精确的
2. 除数为0：
   如果被除数是正数 得到 Infinity
   如果被除数是负数 得到 -Infinity
   如果被除数是0 得到 NaN
  > typeof函数返回类型为string
  > isNaN函数 判断一个数据是否是 NaN
  > isFinite函数 判断一个数据是否有限

### 其他类型使用算术运算
1. 除加号之外的算术运算符
   将原始类型转换为数字类型 然后进行运算
- boolean: true -> 1, false -> 0
- string: 如果字符串内部是一个正确的数字 直接变成数字 如果字符串是一个非数字 则得到NaN 如果字符串是一个空字符串 转换为0
  > NaN虽然是数字 但是与任何数字作运算 得到结果都为NaN
- null: null -> 0
- undefined: undefined -> NaN
  
  将对象类型先转换为字符串类型 然后再将该字符串转换为数字类型
  对象类型 -> "[object Object]" -> NaN
2. 加号运算符
- 加号一边有字符串 变为字符串拼接
  数字 -> 数字字符串
  boolean -> boolean 字符串
  null -> "null"
  undefined -> "undefined"
  对象 -> "[object Object]"
- 加号两边都没有字符串 但一边有对象 将对象转换为字符串 再按以上规则进行
- 其他情况与算术运算一致

## 自增和自减
### 基本功能
一元运算符
++: 将某个变量的值自增1
--: 将某个变量的值自减1

### 细节
#### 自增自减表达式
x++: 将变量x自增1 得到的表达式的值是自增之前的值
++x: 将变量x自增1 得到的表达式的值是自增之后的值
x--: 将变量x自减1 得到的表达式的值是自减之前的值
--x: 将变量x自减1 得到的表达式的值是自减之后的值

#### 优先级
从高到低
1. ```++ --```
2. ```* / %```
3. ```+ -```
优先级的运算细节
1. 从左到右依次查看
2. 如果遇到操作数 将数据的值直接取出
3. 如果遇到相邻的两个运算符 并且左边的运算符优先级大于等于右边的运算符 直接运行左边的运算符

## 比较运算符
大小比较： >  <  >=  <=
相等比较： ==  !=  ===  !==
**比较运算符的返回类型：boolean**
**算数运算符的优先级高于比较运算符**

### 大小比较
#### 细节
1. 两个字符串比较大小 比较的是字符串的字符编码
2. 如果一个不是字符串 并且两个都是原始类型 将它们都转换为数字进行比较
3. 如果其中一个是对象 将对象转换为原始类型 然后按照细节1、2进行比较
   
### 相等比较
#### == 和 !=
**细节**
1. 两端的类型相同 直接比较两个数据本身是否相同
2. 两端的类型不同
  1）null 和 undefined 它们之间相等 和其他原始类型比较 不相等
  2）其他原始类型比较时先转换为数字在进行比较
  3）NaN与任何数字比较都是false 包括自身
  4）Infinity 和 -Infinity 与自身相等
  5）对象比较时先转换为原始类型后在进行比较
**由于相等和不相等比较 对于不同类型的数据比较违反直觉 所以通常我们不适用这种比较方式 而是使用严格相等和严格不相等**

#### === 和 !==
1. 两段类型相同规则与 相等比较 一致
2. 两段类型不同为 false

## 逻辑运算符
### &&
书写方式： 表达式1 && 表达式2
1. 将表达式1进行 boolean 判断
   以下数据判断为false
   1）null
   2）undefined
   3）false
   4）NaN
   5）''
   6）0
2. 如果表达式1 的判断结果为假 则直接返回表达式1 而不执行表达式2 否则返回表达式2的结果（短路规则）

### ||
书写方式： 表达式1 || 表达式2
1. 将表达式1进行 boolean 判断
2. 如果表达式1为真 直接返回表达式1 不运行表达式2 否则返回表达式2
  
### !
书写方式：!数据
将数据的boolean判断结果直接取反

## 三目运算符
书写方式： 表达式1 ? 表达式2 : 表达式3
1. 对表达式1进行 boolean 判断
2. 如果判断结果为真 返回表达式2 否则返回表达式3
   
## 运算符补充
### 类型转换不会影响原本的数据
### 复合的赋值运算符
+=  -=  /=  *=  %=  **=

### void 运算符
1. 普通写法：```void 表达式```
2. 函数写法：```void(表达式)```
运行表达式 然后返回undefined

### typeof 运算符
1. 普通写法：```typeof 表达式```
2. 函数写法：```typeof(表达式)```
返回表达式的类型

### , 运算符
书写方式： 表达式1, 表达式2
依次运行两个表达式 返回表达式2
逗号运算符的优先级比赋值更低


# 流程控制
## if 判断
```js
if(条件1) {
// 代码块
} else if (条件2) {
// 代码块
} else if (条件3) {
// 代码块
} else {
// 代码块
}
```
1. 如果某个条件满足 则直接忽略后面的所有条件
2. else if 可以有0个或多个
3. else 可以有0个或1个
4. 如果代码块只有一条语句 可以省略花括号（不推荐）
5. if 只能出现一次
   
## switch 开关
```js
switch(表达式) {
  case 数据1:
    // 代码块
    break;
  case 数据2:
    // 代码块
    break;
  default: 
    // 代码块
}
```
1. 计算表达式的返回值 依次和case后面的数据进行严格相等的比较 如果某个相等 停止比较 然后运行其内部的代码块 再然后 依次运行之后的所有代码块
2. 在case分支内部使用 break 语句可以立即停止switch结构
3. default表示前面的所有case都不匹配时运行（可省略）

## 循环
JS支持3种循环结构：while循环、do-while循环、for循环
### while 循环
```js
while(条件) {
  // 代码块（循环体）
}
```

### do-while 循环
```js
do {
  // 代码块（循环体）
} while(条件)
```

### for 循环
```js
for(初始化表达式; 条件; 条件改变表达式) {
  // 代码块（循环体）
}
```

### for-in foreach 循环
```js
for(var prop in 对象) {
  // 循环体
}
```
取出对象的所有属性名 每次循环将其中一个属性名赋值给变量prop 运行循环体

### 循环中的关键字
循环控制语句
1. break：跳出循环
2. continue：停止当前循环体 进入下一次循环

## 数组
### 创建一个数组
1. new Array(长度)
   new Array(数据, 数据, 数据...)
2. [数据, 数据, 数据, ...]

### 数组的本质
数组的本质是一个对象
- length属性：数组的长度 会自动变化 值为最大下标+1
- 数字字符串属性：叫做下标 也叫做索引 相当于数组中每个数据的编号 下标从0开始
连续下标的取值范围：0 ~ length-1 如果给length直接赋值 可能会导致数组被截断

### 下标
通常情况下是连续的 不连续的数组叫做稀松数组

### 数组的常见操作
#### 添加数组项
- 数组[长度] = 数据：向数组末尾添加一个数据
- 数组.push(数据)：向数组末尾添加一个数据
- 数组.unshift(数据)：向数组起始位置添加一个数据 会导致数组每一项下标向后移动
- 数据.splice(下标, 0, 添加的数据)：从指定下标位置开始 删除0个 然后在该位置插入添加的数据
  push、unshift、splice可以添加多个数据

#### 删除数据
- delete 数组[下标]：会产生稀松数组 不推荐
- 数组.pop()：删除数组的最后一项 表达式返回最后一项的数据
- 数组.shift()：删除数组的第一项 表达式返回第一项的数据
- 数组.splice(下标, 删除的数量, 添加的数据)：从指定下标位置开始 删除指定数量 然后在该位置插入添加的数据 表达式返回一个新数组 数组记录被删除的数据

#### 其他操作
- 数组.slice(起始位置下标, 结束位置下标)：将起始位置到结束位置之间的数据拿出 得到一个新的数组 不会改变原数组 ```结束下标取不到```
下标可以为负 如果为负数 则从数组末尾开始计算
如果没有结束下标 则直接取到数组末尾
- 数组清空
  数组.splice(0, 数组.length)
  数组.length = 0
- 查找数组中某一项的下标
  数组.indexOf(数据)
  返回找到第一个匹配的下标 如果没有找到 则返回-1
  数组.lastIndexOf(数据)
  返回找到的倒数第一个的下标 如果没有找到 则返回-1
- 数组.fill
  数组.fill(数据)：将数组的所有项 填充为指定数据
  数组.fill(数据, 开始下标)：将数组从开始下标起到数组的末尾 填充为指定的数据
  数组.fill(数组, 开始下标, 结束下标)：将数组从开始下标起到数组的结束下标（取不到），填充为指定的数据

# 函数
## 函数语法
主要用于减少重复代码

### 创建（定义、声明）函数
```js
function 函数名() {
  // 函数体
}
```
函数体不会直接运行 需要手动调用函数才能运行

### 调用函数
```js
函数名()
```

### 函数提升
通过字面量声明的函数 会提升到脚本块的顶部
通过字面量声明的函数 会成为全局对象的属性

### 其他特点
通过typeof(函数名) 得到结果"function"
函数内部声明的变量：
1. 如果不使用var声明 和全局变量一致 表示给全局对象添加属性
2. 如果使用var声明 变量提升到所在函数的顶部 函数外部不能使用该变量
   **函数中声明的变量仅能在函数中使用 在外部无效**

### 参数
表示函数运行的未知条件 需要调用者告知的数据
```js
function 函数名(形参1, 形参2, ...) {

}
函数名(实参)
```
如果实参没有传递 则对应的形参为undefined

### 返回值
函数运行后 得到的结果 调用函数式 调用表达式的值就是函数的返回值
return 会直接结束整个函数的运行
return 后面如果不跟任何数据 返回undefined
如果函数中没有书写return 则该函数会在末尾自动 return undefined

### 文档注释
```js
/**
 *
 *
*/
```

## 作用域与闭包
### 作用域
表示一个代码区域
JS中有两种作用域
1. 全局作用域
   直接在脚本中书写的代码
   在全局作用域中声明的变量 会被提升到脚本块的顶部 并且成为全局对象的属性
2. 函数作用域
   函数中的代码
   在函数作用域中声明的变量 会被提升到函数的顶部 并且不会成为全局对象的属性
   **函数中声明的变量不会导致全局对象的污染**
   **尽量把功能封装在函数中**
   当函数成为一个表达式时 它既不会提升 也不会污染全局对象
   将函数变成一个函数表达式的方式之一 将函数用小括号括起来
   这样一来函数无法通过名称调用
   如果书写一个函数表达式 然后立即调用 该函数称为立即执行函数
   没有名字的函数 称为匿名函数

### 作用域中可以使用的变量（包括函数）
全局作用域只能使用全局作用域中声明的变量
函数作用域不仅能使用自身作用域中声明的变量 还能使用外部环境的变量
有的时候某个函数比较复杂 在编写的过程中 可能需要另外一些函数来辅助完成一些功能  而这些函数仅会被该函数使用 不会在其他位置使用 则可以将这些函数声明到该函数的内部
函数内部声明的变量和外部冲突时 使用内部变量

### 闭包
一种现象 内部函数可以使用外部函数环境中的变量

## 函数表达式与this
### 函数表达式
JS中函数也是一个数据 语法上函数可以用于任何需要数据的地方
函数是一个引用类型 将其赋值给某个变量时 变量中保存的是函数的地址

### this关键字
> this无法赋值
1. 在全局作用域中 this关键字固定指向全局对象
2. 在函数作用域中 取决于函数是如何被调用的
   1、函数直接调用 this指向全局对象
   2、通过一个对象的属性调用 格式为```对象.属性()```或```属性["属性"]()``` this指向对象

## 构造函数
> 对象中的属性 如果是一个函数 也称该属性为对象的方法

### 用于创建对象的函数
减少繁琐的对象创建流程
1. 函数返回一个对象
2. 构造函数：构造函数专门用于创建对象
```js
new 函数名(参数)
```
如果使用上面的格式创建对象 则该函数叫做构造函数
1）函数名使用大驼峰命名法
2）构造函数内部 会自动创建一个新对象 this指向新创建的对象 并自动返回新对象
3）构造函数中如果出现返回值 如果返回的是原始类型 直接忽略 如果返回的是引用类型 则使用返回的结果
4）所有的对象都是通过构造函数创建的

### new.target
该表达式在函数中使用 返回的是当前的构造函数 但是如果该函数不是通过new调用的 则返回undefined
通常用于判断某个函数是否是通过new在调用

## 函数的本质
函数的本质是对象
> 所有的对象都是通过关键字new出来的```new 构造函数()```
所有的函数都是通过```new Function```创建的
> Function
由于函数本身就是对象 所以函数可以拥有各种属性

### 包装类
JS为了增强原始类型的功能 为boolean string number分别创建了一个构造函数：
1. Boolean
2. String
3. Number
如果语法上将原始类型当做对象使用JS会自动在该位置利用对应的构造函数创建对象来访问原始类型的属性
> 类：构造函数
> 成员属性（方法）、实例属性（方法）：表示该属性是通过构造函数创建的对象调用的
> 静态属性（方法）、类属性（方法）：表示该属性是通过构造函数本身调用的

## 递归
函数直接或间接调用自身
避免无限递归
与死循环对比
- 死循环不会报错 也不会导致栈溢出
- 无限递归会导致栈溢出

### 执行栈
任何代码的执行都必须有一个执行环境 执行环境为代码的执行提供支持
执行环境是放到执行栈中的
每个函数的调用 都需要创建一个函数的执行环境 函数调用结束 执行环境销毁
执行栈有相对固定的大小 如果执行环境太多 执行栈无法容纳 会报错

### 尾递归
古国一个函数最后一条语句是调用函数 并且调用函数不是表达式的一部分 则该语句成为尾调用 如果尾调用是调用自身函数 则称为尾递归